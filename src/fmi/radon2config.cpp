#include "grid-files/common/Exception.h"
#include "grid-files/common/ShowFunction.h"
#include "grid-files/common/GeneralFunctions.h"
#include "grid-files/common/ShowFunction.h"
#include "grid-files/identification/GridDef.h"

#include <libpq-fe.h>
#include <stdlib.h>
#include <string.h>

#define FUNCTION_TRACE FUNCTION_TRACE_OFF


using namespace SmartMet;




void error(char *mess)
{
  fprintf(stderr, "### %s\n", mess);
  exit(1);
}




void create_fmi_geometries(PGconn *conn,const char *dir)
{
  FUNCTION_TRACE
  try
  {
    char filename[300];
    sprintf(filename,"%s/fmi_geometries.csv",dir);

    FILE *file = fopen(filename,"we");
    if (file == nullptr)
    {
      SmartMet::Spine::Exception exception(BCP,"Cannot create the file!");
      exception.addParameter("Filename",filename);
      throw exception;
    }

    fprintf(file,"# This file is automatically generated by the 'radon2config' program. It is used for mapping FMI geometries\n");
    fprintf(file,"# (defined in the Radon database) into the geometries defined in GRIB files.\n");
    fprintf(file,"#\n");
    fprintf(file,"# Do not edit this file, because all changes will be overridden.\n");
    fprintf(file,"#\n");


    fprintf(file,"\n# LATLON : projection,id,name,ni,nj,first_point.x,first_point.y,di,dj,scanning_mode,description\n");

    char sql[3000];
    char *p = sql;

    p += sprintf(p,"SELECT\n");
    p += sprintf(p,"  %u,\n",T::GridProjectionValue::LatLon);
    p += sprintf(p,"  id,\n");
    p += sprintf(p,"  name,\n");
    p += sprintf(p,"  ni,\n");
    p += sprintf(p,"  nj,\n");
    p += sprintf(p,"  ST_X(first_point),\n");
    p += sprintf(p,"  ST_Y(first_point),\n");
    p += sprintf(p,"  di,\n");
    p += sprintf(p,"  dj,\n");
    p += sprintf(p,"  scanning_mode,\n");
    p += sprintf(p,"  description\n");
    p += sprintf(p,"FROM\n");
    p += sprintf(p,"  geom_latitude_longitude\n");
    p += sprintf(p,"ORDER BY\n");
    p += sprintf(p,"  id;\n");

    PGresult *res = PQexec(conn,sql);
    if (PQresultStatus(res) != PGRES_TUPLES_OK)
      error(PQresultErrorMessage(res));

    int fieldCount = PQnfields(res);
    int rowCount = PQntuples(res);

    for (int i = 0; i < rowCount; i++)
    {
      for (int f=0; f< fieldCount; f++)
      {
        fprintf(file,"%s;",PQgetvalue(res,i,f));
      }
      fprintf(file,"\n");
    }

    PQclear(res);


    fprintf(file,"\n# ROTATED LATLON : projection,id,name,ni,nj,first_point.x,first_point.y,di,dj,scanning_mode,south_pole.x,south_pole.y,angle,description\n");

    p = sql;

    p += sprintf(p,"SELECT\n");
    p += sprintf(p,"  %u,\n",T::GridProjectionValue::RotatedLatLon);
    p += sprintf(p,"  id,\n");
    p += sprintf(p,"  name,\n");
    p += sprintf(p,"  ni,\n");
    p += sprintf(p,"  nj,\n");
    p += sprintf(p,"  ST_X(first_point),\n");
    p += sprintf(p,"  ST_Y(first_point),\n");
    p += sprintf(p,"  di,\n");
    p += sprintf(p,"  dj,\n");
    p += sprintf(p,"  scanning_mode,\n");
    p += sprintf(p,"  ST_X(south_pole),\n");
    p += sprintf(p,"  ST_Y(south_pole),\n");
    p += sprintf(p,"  0,\n");                  // Angle of rotation
    p += sprintf(p,"  description\n");
    p += sprintf(p,"FROM\n");
    p += sprintf(p,"  geom_rotated_latitude_longitude\n");
    p += sprintf(p,"ORDER BY\n");
    p += sprintf(p,"  id;\n");


    res = PQexec(conn,sql);
    if (PQresultStatus(res) != PGRES_TUPLES_OK)
      error(PQresultErrorMessage(res));

    fieldCount = PQnfields(res);
    rowCount = PQntuples(res);

    for (int i = 0; i < rowCount; i++)
    {
      for (int f=0; f< fieldCount; f++)
      {
        fprintf(file,"%s;",PQgetvalue(res,i,f));
      }
      fprintf(file,"\n");
    }

    PQclear(res);


    fprintf(file,"\n# LAMBERT CONFORMAL : projection,id,name,ni,nj,first_point.x,first_point.y,di,dj,scanning_mode,orientation,latin1,latin2,south_pole.x,south_pole.y,LaD,description\n");

    p = sql;

    p += sprintf(p,"SELECT\n");
    p += sprintf(p,"  %u,\n",T::GridProjectionValue::LambertConformal);
    p += sprintf(p,"  id,\n");
    p += sprintf(p,"  name,\n");
    p += sprintf(p,"  ni,\n");
    p += sprintf(p,"  nj,\n");
    p += sprintf(p,"  ST_X(first_point),\n");
    p += sprintf(p,"  ST_Y(first_point),\n");
    p += sprintf(p,"  di,\n");
    p += sprintf(p,"  dj,\n");
    p += sprintf(p,"  scanning_mode,\n");
    p += sprintf(p,"  orientation,\n");
    p += sprintf(p,"  latin1,\n");
    p += sprintf(p,"  latin2,\n");
    p += sprintf(p,"  ST_X(south_pole),\n");
    p += sprintf(p,"  ST_Y(south_pole),\n");
    p += sprintf(p,"  60.0,\n");                  // LaD
    p += sprintf(p,"  description\n");
    p += sprintf(p,"FROM\n");
    p += sprintf(p,"  geom_lambert_conformal\n");
    p += sprintf(p,"ORDER BY\n");
    p += sprintf(p,"  id;\n");


    res = PQexec(conn,sql);
    if (PQresultStatus(res) != PGRES_TUPLES_OK)
      error(PQresultErrorMessage(res));

    fieldCount = PQnfields(res);
    rowCount = PQntuples(res);

    for (int i = 0; i < rowCount; i++)
    {
      for (int f=0; f< fieldCount; f++)
      {
        fprintf(file,"%s;",PQgetvalue(res,i,f));
      }
      fprintf(file,"\n");
    }

    PQclear(res);


    fprintf(file,"\n# GAUSSIAN : projection,id,name,nj,first_point.x,first_point.y,scanning_mode,n,point_along_parallels,description\n");

    p = sql;

    p += sprintf(p,"SELECT\n");
    p += sprintf(p,"  %u,\n",T::GridProjectionValue::Gaussian);
    p += sprintf(p,"  id,\n");
    p += sprintf(p,"  name,\n");
    p += sprintf(p,"  nj,\n");
    p += sprintf(p,"  ST_X(first_point),\n");
    p += sprintf(p,"  ST_Y(first_point),\n");
    p += sprintf(p,"  scanning_mode,\n");
    p += sprintf(p,"  n,\n");
    p += sprintf(p,"  points_along_parallels,\n");
    p += sprintf(p,"  description\n");
    p += sprintf(p,"FROM\n");
    p += sprintf(p,"  geom_reduced_gaussian\n");
    p += sprintf(p,"ORDER BY\n");
    p += sprintf(p,"  id;\n");


    res = PQexec(conn,sql);
    if (PQresultStatus(res) != PGRES_TUPLES_OK)
      error(PQresultErrorMessage(res));

    fieldCount = PQnfields(res);
    rowCount = PQntuples(res);

    for (int i = 0; i < rowCount; i++)
    {
      for (int f=0; f< fieldCount; f++)
      {
        fprintf(file,"%s;",PQgetvalue(res,i,f));
      }
      fprintf(file,"\n");
    }

    PQclear(res);


    fprintf(file,"\n# POLAR STEREOGRAPHIC : projection,id,name,ni,nj,first_point.x,first_point.y,di,dj,scanning_mode,orientation,laD,description\n");

    p = sql;

    p += sprintf(p,"SELECT\n");
    p += sprintf(p,"  %u,\n",T::GridProjectionValue::PolarStereographic);
    p += sprintf(p,"  id,\n");
    p += sprintf(p,"  name,\n");
    p += sprintf(p,"  ni,\n");
    p += sprintf(p,"  nj,\n");
    p += sprintf(p,"  ST_X(first_point),\n");
    p += sprintf(p,"  ST_Y(first_point),\n");
    p += sprintf(p,"  di,\n");
    p += sprintf(p,"  dj,\n");
    p += sprintf(p,"  scanning_mode,\n");
    p += sprintf(p,"  orientation,\n");
    p += sprintf(p,"  60.0,\n");
    p += sprintf(p,"  description\n");
    p += sprintf(p,"FROM\n");
    p += sprintf(p,"  geom_stereographic\n");
    p += sprintf(p,"ORDER BY\n");
    p += sprintf(p,"  id;\n");


    res = PQexec(conn,sql);
    if (PQresultStatus(res) != PGRES_TUPLES_OK)
      error(PQresultErrorMessage(res));

    fieldCount = PQnfields(res);
    rowCount = PQntuples(res);

    for (int i = 0; i < rowCount; i++)
    {
      for (int f=0; f< fieldCount; f++)
      {
        fprintf(file,"%s;",PQgetvalue(res,i,f));
      }
      fprintf(file,"\n");
    }

    PQclear(res);

    fclose(file);
  }
  catch (...)
  {
    throw SmartMet::Spine::Exception(BCP, exception_operation_failed, nullptr);
  }
}




void create_fmi_levelId_grib2(PGconn *conn,const char *dir)
{
  FUNCTION_TRACE
  try
  {
    char filename[300];
    sprintf(filename,"%s/fmi_levelId_grib2.csv",dir);

    FILE *file = fopen(filename,"we");
    if (file == nullptr)
    {
      SmartMet::Spine::Exception exception(BCP,"Cannot create the file!");
      exception.addParameter("Filename",filename);
      throw exception;
    }

    fprintf(file,"# This file is automatically generated by the 'radon2config' program. It is used for mapping FMI level\n");
    fprintf(file,"# identifier (defined in the Radon database) into the level identifiers used in GRIB2 files.\n");
    fprintf(file,"#\n");
    fprintf(file,"# Do not edit this file, because all changes will be overridden.\n");
    fprintf(file,"#\n");
    fprintf(file,"# FIELDS:\n");
    fprintf(file,"# 1) FmiLevelId\n");
    fprintf(file,"# 2) FmiProducerId\n");
    fprintf(file,"# 3) GeneratingProcessIdentifier\n");
    fprintf(file,"# 4) Centre\n");
    fprintf(file,"# 5) Grib2LevelIdentifier\n");
    fprintf(file,"#\n");


    char sql[3000];
    char *p = sql;

    p += sprintf(p,"SELECT DISTINCT\n");
    p += sprintf(p,"  level_grib2.level_id,\n");
    p += sprintf(p,"  level_grib2.producer_id,\n");
    p += sprintf(p,"  producer_grib.ident,\n");
    p += sprintf(p,"  producer_grib.centre,\n");
    p += sprintf(p,"  level_grib2.grib_level_id\n");
    p += sprintf(p,"FROM\n");
    p += sprintf(p,"  level_grib2 LEFT OUTER JOIN producer_grib ON (level_grib2.producer_id = producer_grib.producer_id)\n");
    p += sprintf(p,"ORDER BY\n");
    p += sprintf(p,"  level_grib2.level_id,level_grib2.producer_id,producer_grib.ident,producer_grib.centre,level_grib2.grib_level_id;\n");


    PGresult *res = PQexec(conn,sql);
    if (PQresultStatus(res) != PGRES_TUPLES_OK)
      error(PQresultErrorMessage(res));

    int fieldCount = PQnfields(res);
    int rowCount = PQntuples(res);

    for (int i = 0; i < rowCount; i++)
    {
      for (int f=0; f< fieldCount; f++)
      {
        fprintf(file,"%s;",PQgetvalue(res,i,f));
      }
      fprintf(file,"\n");
    }

    fclose(file);
    PQclear(res);
  }
  catch (...)
  {
    throw SmartMet::Spine::Exception(BCP, exception_operation_failed, nullptr);
  }
}





void create_fmi_levels(PGconn *conn,const char *dir)
{
  FUNCTION_TRACE
  try
  {
    char filename[300];
    sprintf(filename,"%s/fmi_levels.csv",dir);

    FILE *file = fopen(filename,"we");
    if (file == nullptr)
    {
      SmartMet::Spine::Exception exception(BCP,"Cannot create the file!");
      exception.addParameter("Filename",filename);
      throw exception;
    }

    fprintf(file,"# This file is automatically generated by the 'radon2config' program.\n");
    fprintf(file,"#\n");
    fprintf(file,"# Do not edit this file, because all changes will be overridden.\n");
    fprintf(file,"#\n");
    fprintf(file,"# FIELDS:\n");
    fprintf(file,"# 1) FmiLevelId\n");
    fprintf(file,"# 2) FmiLevelName\n");
    fprintf(file,"# 3) Description\n");
    fprintf(file,"#\n");


    char sql[3000];
    char *p = sql;

    p += sprintf(p,"SELECT \n");
    p += sprintf(p,"  id,\n");
    p += sprintf(p,"  name,\n");
    p += sprintf(p,"  description\n");
    p += sprintf(p,"FROM\n");
    p += sprintf(p,"  level\n");
    p += sprintf(p,"ORDER BY\n");
    p += sprintf(p,"  id;\n");


    PGresult *res = PQexec(conn,sql);
    if (PQresultStatus(res) != PGRES_TUPLES_OK)
      error(PQresultErrorMessage(res));

    int fieldCount = PQnfields(res);
    int rowCount = PQntuples(res);

    for (int i = 0; i < rowCount; i++)
    {
      for (int f=0; f< fieldCount; f++)
      {
        fprintf(file,"%s;",PQgetvalue(res,i,f));
      }
      fprintf(file,"\n");
    }

    fclose(file);
    PQclear(res);
  }
  catch (...)
  {
    throw SmartMet::Spine::Exception(BCP, exception_operation_failed, nullptr);
  }
}





void create_fmi_levelId_grib1(PGconn *conn,const char *dir)
{
  FUNCTION_TRACE
  try
  {
    char filename[300];
    sprintf(filename,"%s/fmi_levelId_grib1.csv",dir);

    FILE *file = fopen(filename,"we");
    if (file == nullptr)
    {
      SmartMet::Spine::Exception exception(BCP,"Cannot create the file!");
      exception.addParameter("Filename",filename);
      throw exception;
    }

    fprintf(file,"# This file is automatically generated by the 'radon2config' program. It is used for mapping FMI level\n");
    fprintf(file,"# identifier (defined in the Radon database) into the level identifiers used in GRIB1 files.\n");
    fprintf(file,"#\n");
    fprintf(file,"# Do not edit this file, because all changes will be overridden.\n");
    fprintf(file,"#\n");
    fprintf(file,"# FIELDS:\n");
    fprintf(file,"# 1) FmiLevelId\n");
    fprintf(file,"# 2) FmiProducerId\n");
    fprintf(file,"# 3) GeneratingProcessIdentifier\n");
    fprintf(file,"# 4) Centre\n");
    fprintf(file,"# 5) Grib1LevelIdentifier\n");
    fprintf(file,"#\n");


    char sql[3000];
    char *p = sql;

    p += sprintf(p,"SELECT DISTINCT\n");
    p += sprintf(p,"  level_grib1.level_id,\n");
    p += sprintf(p,"  level_grib1.producer_id,\n");
    p += sprintf(p,"  producer_grib.ident,\n");
    p += sprintf(p,"  producer_grib.centre,\n");
    p += sprintf(p,"  level_grib1.grib_level_id\n");
    p += sprintf(p,"FROM\n");
    p += sprintf(p,"  level_grib1 LEFT OUTER JOIN producer_grib ON (level_grib1.producer_id = producer_grib.producer_id)\n");
    p += sprintf(p,"ORDER BY\n");
    p += sprintf(p,"  level_grib1.level_id,level_grib1.producer_id,producer_grib.ident,producer_grib.centre,level_grib1.grib_level_id;\n");


    PGresult *res = PQexec(conn,sql);
    if (PQresultStatus(res) != PGRES_TUPLES_OK)
      error(PQresultErrorMessage(res));

    int fieldCount = PQnfields(res);
    int rowCount = PQntuples(res);

    for (int i = 0; i < rowCount; i++)
    {
      for (int f=0; f< fieldCount; f++)
      {
        fprintf(file,"%s;",PQgetvalue(res,i,f));
      }
      fprintf(file,"\n");
    }

    fclose(file);
    PQclear(res);
  }
  catch (...)
  {
    throw SmartMet::Spine::Exception(BCP, exception_operation_failed, nullptr);
  }
}





void create_fmi_parameterId_grib2(PGconn *conn,const char *dir)
{
  FUNCTION_TRACE
  try
  {
    char filename[300];
    sprintf(filename,"%s/fmi_parameterId_grib2.csv",dir);

    FILE *file = fopen(filename,"we");
    if (file == nullptr)
    {
      SmartMet::Spine::Exception exception(BCP,"Cannot create the file!");
      exception.addParameter("Filename",filename);
      throw exception;
    }

    fprintf(file,"# This file is automatically generated by the 'radon2config' program. It defines mappings between\n");
    fprintf(file,"# FMI identifiers (used in Radon database) and identifiers used in GRIB2 files.\n");
    fprintf(file,"#\n");
    fprintf(file,"# Do not edit this file, because all changes will be overridden.\n");
    fprintf(file,"# You can add your own mappings into the 'fmi_parameterId_grib2_ext.csv' file.\n");
    fprintf(file,"#\n");
    fprintf(file,"# FIELDS:\n");
    fprintf(file,"# 1) FmiParameterId\n");
    fprintf(file,"# 2) FmiProducerId\n");
    fprintf(file,"# 3) GeneratingProcessIdentifier\n");
    fprintf(file,"# 4) Centre\n");
    fprintf(file,"# 5) Discipline\n");
    fprintf(file,"# 6) ParameterCategory\n");
    fprintf(file,"# 7) ParameterNumber\n");
    fprintf(file,"# 8) FmiParameterLevelId\n");
    fprintf(file,"# 9) GribParameterLevelId\n");
    fprintf(file,"# 10) ParameterLevel\n");
    fprintf(file,"#\n");

    char sql[3000];
    char *p = sql;

    p += sprintf(p,"SELECT DISTINCT\n");
    p += sprintf(p,"  param_grib2.param_id,\n");
    p += sprintf(p,"  param_grib2.producer_id,\n");
    p += sprintf(p,"  producer_grib.ident,\n");
    p += sprintf(p,"  producer_grib.centre,\n");
    p += sprintf(p,"  param_grib2.discipline,\n");
    p += sprintf(p,"  param_grib2.category,\n");
    p += sprintf(p,"  param_grib2.number,\n");
    p += sprintf(p,"  param_grib2.level_id,\n");
    p += sprintf(p,"  level_grib2.grib_level_id,\n");
    p += sprintf(p,"  param_grib2.level_value\n");
    p += sprintf(p,"FROM\n");
    p += sprintf(p,"  param_grib2 LEFT OUTER JOIN producer_grib ON (param_grib2.producer_id=producer_grib.producer_id)\n");
    p += sprintf(p,"  LEFT OUTER JOIN level_grib2 ON (param_grib2.level_id=level_grib2.level_id)\n");
    p += sprintf(p,"ORDER BY\n");
    p += sprintf(p,"  param_grib2.param_id,param_grib2.producer_id,producer_grib.ident;\n");

    PGresult *res = PQexec(conn,sql);
    if (PQresultStatus(res) != PGRES_TUPLES_OK)
      error(PQresultErrorMessage(res));

    int fieldCount = PQnfields(res);
    int rowCount = PQntuples(res);

    for (int i = 0; i < rowCount; i++)
    {
      for (int f=0; f< fieldCount; f++)
      {
        fprintf(file,"%s;",PQgetvalue(res,i,f));
      }
      fprintf(file,"\n");
    }

    fclose(file);
    PQclear(res);
  }
  catch (...)
  {
    throw SmartMet::Spine::Exception(BCP, exception_operation_failed, nullptr);
  }
}




void create_fmi_parameterId_grib1(PGconn *conn,const char *dir)
{
  FUNCTION_TRACE
  try
  {
    char filename[300];
    sprintf(filename,"%s/fmi_parameterId_grib1.csv",dir);

    FILE *file = fopen(filename,"we");
    if (file == nullptr)
    {
      SmartMet::Spine::Exception exception(BCP,"Cannot create the file!");
      exception.addParameter("Filename",filename);
      throw exception;
    }

    fprintf(file,"# This file is automatically generated by the 'radon2config' program. It defines mappings between\n");
    fprintf(file,"# FMI identifiers (used in Radon database) and identifiers used in GRIB1 files.\n");
    fprintf(file,"#\n");
    fprintf(file,"# Do not edit this file, because all changes will be overridden.\n");
    fprintf(file,"# You can add your own mappings into the 'fmi_parameterId_grib1_ext.csv' file.\n");
    fprintf(file,"#\n");
    fprintf(file,"# FIELDS:\n");
    fprintf(file,"# 1) FmiParameterId\n");
    fprintf(file,"# 2) FmiProducerId\n");
    fprintf(file,"# 3) GeneratingProcessIdentifier\n");
    fprintf(file,"# 4) Centre\n");
    fprintf(file,"# 5) mGribTableVersion\n");
    fprintf(file,"# 6) mGribParameterNumber\n");
    fprintf(file,"# 7) mGribTimerangeIndicator\n");
    fprintf(file,"# 8) FmiParameterLevelId\n");
    fprintf(file,"# 9) GribParameterLevelId\n");
    fprintf(file,"# 10) ParameterLevel\n");
    fprintf(file,"#\n");

    char sql[3000];
    char *p = sql;

    p += sprintf(p,"SELECT DISTINCT\n");
    p += sprintf(p,"  param_grib1.param_id,\n");
    p += sprintf(p,"  param_grib1.producer_id,\n");
    p += sprintf(p,"  producer_grib.ident,\n");
    p += sprintf(p,"  producer_grib.centre,\n");
    p += sprintf(p,"  param_grib1.table_version,\n");
    p += sprintf(p,"  param_grib1.number,\n");
    p += sprintf(p,"  param_grib1.timerange_indicator,\n");
    p += sprintf(p,"  param_grib1.level_id,\n");
    p += sprintf(p,"  level_grib1.grib_level_id,\n");
    p += sprintf(p,"  param_grib1.level_value\n");
    p += sprintf(p,"FROM\n");
    p += sprintf(p,"  param_grib1 LEFT OUTER JOIN producer_grib ON (param_grib1.producer_id=producer_grib.producer_id)\n");
    p += sprintf(p,"  LEFT OUTER JOIN level_grib1 ON (param_grib1.level_id=level_grib1.level_id)\n");
    p += sprintf(p,"ORDER BY\n");
    p += sprintf(p,"  param_grib1.param_id,param_grib1.producer_id,producer_grib.ident;\n");


    PGresult *res = PQexec(conn,sql);
    if (PQresultStatus(res) != PGRES_TUPLES_OK)
      error(PQresultErrorMessage(res));

    int fieldCount = PQnfields(res);
    int rowCount = PQntuples(res);

    for (int i = 0; i < rowCount; i++)
    {
      for (int f=0; f< fieldCount; f++)
      {
        fprintf(file,"%s;",PQgetvalue(res,i,f));
      }
      fprintf(file,"\n");
    }

    fclose(file);
    PQclear(res);
  }
  catch (...)
  {
    throw SmartMet::Spine::Exception(BCP, exception_operation_failed, nullptr);
  }
}




void create_fmi_parameterId_newbase(PGconn *conn,const char *dir)
{
  FUNCTION_TRACE
  try
  {
    char filename[300];
    sprintf(filename,"%s/fmi_parameterId_newbase.csv",dir);

    FILE *file = fopen(filename,"we");
    if (file == nullptr)
    {
      SmartMet::Spine::Exception exception(BCP,"Cannot create the file!");
      exception.addParameter("Filename",filename);
      throw exception;
    }

    fprintf(file,"# This file is automatically generated by the 'radon2config' program. It defines FMI parameters used\n");
    fprintf(file,"# in the Radon database.\n");
    fprintf(file,"#\n");
    fprintf(file,"# Do not edit this file, because all changes will be overridden.\n");
    fprintf(file,"#\n");
    fprintf(file,"# FIELDS:\n");
    fprintf(file,"# 1) FmiParameterId\n");
    fprintf(file,"# 2) NewbaseParameterId\n");
    fprintf(file,"# 3) ConversionFunction\n");
    fprintf(file,"# 4) ReverseConversionFunction\n");
    fprintf(file,"#\n");

    char sql[3000];
    char *p = sql;

    p += sprintf(p,"SELECT DISTINCT\n");
    p += sprintf(p,"  param.name,\n");
    p += sprintf(p,"  param.description,\n");
    p += sprintf(p,"  param.id,\n");
    p += sprintf(p,"  coalesce(param_newbase.univ_id,0),\n");
    p += sprintf(p,"  param_newbase.base,\n");
    p += sprintf(p,"  param_newbase.scale,\n");
    p += sprintf(p,"  param_unit.name\n");
    p += sprintf(p,"FROM\n");
    p += sprintf(p,"  param LEFT OUTER JOIN param_newbase ON (param.id = param_newbase.param_id),param_unit\n");
    p += sprintf(p,"WHERE\n");
    p += sprintf(p,"  param.unit_id=param_unit.id\n");
    // p += sprintf(p,"  param.unit_id=param_unit.id AND param_newbase.base = 0 AND param_newbase.scale = 1\n");
    p += sprintf(p,"ORDER BY\n");
    p += sprintf(p,"  param.id;\n");


    PGresult *res = PQexec(conn,sql);
    if (PQresultStatus(res) != PGRES_TUPLES_OK)
      error(PQresultErrorMessage(res));

    //int fieldCount = PQnfields(res);
    int rowCount = PQntuples(res);

    for (int i = 0; i < rowCount; i++)
    {
      std::string newbaseId = PQgetvalue(res,i,3);
      double base = toDouble(PQgetvalue(res,i,4));
      double scale = toDouble(PQgetvalue(res,i,5));
      std::string unit = PQgetvalue(res,i,6);


      Identification::NewbaseParameterDef paramDef;
      fprintf(file,"\n# %s\n",PQgetvalue(res,i,1));
      if (newbaseId > "0")
      {
        if (Identification::gridDef.getNewbaseParameterDefById(newbaseId,paramDef))
          fprintf(file,"# %s => %s\n",PQgetvalue(res,i,0),paramDef.mParameterName.c_str());
        else
          fprintf(file,"# %s => NEWBASE-PARAMETER[%s]\n",PQgetvalue(res,i,0),newbaseId.c_str());
      }
      else
        fprintf(file,"# %s => UNKNOWN\n",PQgetvalue(res,i,0));

      fprintf(file,"%s;%s;",PQgetvalue(res,i,2),PQgetvalue(res,i,3));

      // We have to do some assumption when we define conversion functions. That's because
      // there seems to be a lot of strange conversion mappings in the Radon database.

      if (newbaseId > "0")
      {
        if (unit == "K")
        {
          fprintf(file,"SUM{$,-273.15};SUM{$,273.15};"); // Converting all kelvin values to celcius (assuming that the newbase has no Kelvin parameters)
        }
        else
        if (unit == "C")
          fprintf(file,";;\n"); // Assuming that celcius parameters do not need any conversion)
        else
        if (base != 0  &&  scale == 1)
        {
          fprintf(file,"SUM{$,%f};SUM{$,%f};",base,-base);
        }
        else
        if (base == 0  &&  scale != 1  &&  scale != 0)
        {
          fprintf(file,"MUL{$,%f};DIV{$,%f};",scale,scale);
        }
        else
          fprintf(file,";;");
      }
      else
        fprintf(file,";;\n");
    }

    fclose(file);
    PQclear(res);
  }
  catch (...)
  {
    throw SmartMet::Spine::Exception(BCP, exception_operation_failed, nullptr);
  }
}




void create_fmi_parameters(PGconn *conn,const char *dir)
{
  FUNCTION_TRACE
  try
  {
    char filename[300];
    sprintf(filename,"%s/fmi_parameters.csv",dir);

    FILE *file = fopen(filename,"we");
    if (file == nullptr)
    {
      SmartMet::Spine::Exception exception(BCP,"Cannot create the file!");
      exception.addParameter("Filename",filename);
      throw exception;
    }

    fprintf(file,"# This file is automatically generated by the 'radon2config' program. It defines FMI parameters used\n");
    fprintf(file,"# in the Radon database.\n");
    fprintf(file,"#\n");
    fprintf(file,"# Do not edit this file, because all changes will be overridden.\n");
    fprintf(file,"#\n");
    fprintf(file,"# FIELDS:\n");
    fprintf(file,"# 1) FmiParameterId\n");
    fprintf(file,"# 2) Version\n");
    fprintf(file,"# 3) FmiParameterName\n");
    fprintf(file,"# 4) FmiParameterDescription\n");
    fprintf(file,"# 5) AreaInterpolationMethod\n");
    fprintf(file,"# 6) TimeInterpolationMethod\n");
    fprintf(file,"# 7) LevelInterpolationMethod\n");
    fprintf(file,"# 8) DefaultPrecision\n");
    fprintf(file,"#\n");

    char sql[3000];
    char *p = sql;

    p += sprintf(p,"SELECT DISTINCT\n");
    p += sprintf(p,"  param.id,\n");
    p += sprintf(p,"  param.version,\n");
    p += sprintf(p,"  param.name,\n");
    p += sprintf(p,"  param_unit.name,\n");
    p += sprintf(p,"  param.description,\n");
    p += sprintf(p,"  param.interpolation_id,\n");
    p += sprintf(p,"  param.interpolation_id,\n");
    p += sprintf(p,"  param.interpolation_id\n");
    p += sprintf(p,"FROM\n");
    p += sprintf(p,"  param,param_unit\n");
    p += sprintf(p,"WHERE\n");
    p += sprintf(p,"  param.unit_id=param_unit.id\n");
    p += sprintf(p,"ORDER BY\n");
    p += sprintf(p,"  param.id;\n");


    PGresult *res = PQexec(conn,sql);
    if (PQresultStatus(res) != PGRES_TUPLES_OK)
      error(PQresultErrorMessage(res));

    int fieldCount = PQnfields(res);
    int rowCount = PQntuples(res);

    for (int i = 0; i < rowCount; i++)
    {
      for (int f=0; f < fieldCount; f++)
      {
        fprintf(file,"%s;",PQgetvalue(res,i,f));
      }
      std::string unit = PQgetvalue(res,i,3);

      if (unit == "C" || unit == "K" || unit == "m s-1" || unit == "cm" || unit == "mm")
        fprintf(file,"1;\n");
      else
      if (unit == "m" || unit == "kg")
        fprintf(file,"2;\n");
      else
        fprintf(file,";\n");
    }

    fclose(file);
    PQclear(res);
  }
  catch (...)
  {
    throw SmartMet::Spine::Exception(BCP, exception_operation_failed, nullptr);
  }
}




void create_fmi_producerId_grib(PGconn *conn,const char *dir)
{
  FUNCTION_TRACE
  try
  {
    char filename[300];
    sprintf(filename,"%s/fmi_producerId_grib.csv",dir);

    FILE *file = fopen(filename,"we");
    if (file == nullptr)
    {
      SmartMet::Spine::Exception exception(BCP,"Cannot create the file!");
      exception.addParameter("Filename",filename);
      throw exception;
    }

    fprintf(file,"# This file is automatically generated by the 'radon2config' program. It defines FMI producers used\n");
    fprintf(file,"# in the Radon database and their mappings to GRIB producers.\n");
    fprintf(file,"#\n");
    fprintf(file,"# Do not edit this file, because all changes will be overridden.\n");
    fprintf(file,"#\n");
    fprintf(file,"# FIELDS:\n");
    fprintf(file,"# 1) FmiProducerId\n");
    fprintf(file,"# 2) Type\n");
    fprintf(file,"# 3) Centre\n");
    fprintf(file,"# 4) GeneratingProcessIdentifier\n");
    fprintf(file,"# 5) FmiProducerName\n");
    fprintf(file,"# 6) FmiProducerDescription\n");
    fprintf(file,"#\n");


    char sql[3000];
    char *p = sql;

    p += sprintf(p,"SELECT DISTINCT\n");
    p += sprintf(p,"  fmi_producer.id,\n");
    p += sprintf(p,"  fmi_producer.type_id,\n");
    p += sprintf(p,"  producer_grib.centre,\n");
    p += sprintf(p,"  producer_grib.ident,\n");
    p += sprintf(p,"  fmi_producer.name,\n");
    p += sprintf(p,"  fmi_producer.description\n");
    p += sprintf(p,"FROM\n");
    p += sprintf(p,"  fmi_producer LEFT OUTER JOIN producer_grib ON (fmi_producer.id = producer_grib.producer_id)\n");
    //p += sprintf(p,"  fmi_producer,producer_grib\n");
    //p += sprintf(p,"WHERE\n");
    //p += sprintf(p,"  fmi_producer.id=producer_grib.producer_id\n");
    p += sprintf(p,"ORDER BY\n");
    p += sprintf(p,"  fmi_producer.id,producer_grib.centre,producer_grib.ident;\n");

    PGresult *res = PQexec(conn,sql);
    if (PQresultStatus(res) != PGRES_TUPLES_OK)
      error(PQresultErrorMessage(res));

    int fieldCount = PQnfields(res);
    int rowCount = PQntuples(res);

    for (int i = 0; i < rowCount; i++)
    {
      for (int f=0; f< fieldCount; f++)
      {
        fprintf(file,"%s;",PQgetvalue(res,i,f));
      }
      fprintf(file,"\n");
    }

    fclose(file);
    PQclear(res);
  }
  catch (...)
  {
    throw SmartMet::Spine::Exception(BCP, exception_operation_failed, nullptr);
  }
}





int main(int argc, char *argv[])
{
  FUNCTION_TRACE
  try
  {
    if (argc != 3)
    {
      fprintf(stderr,"USAGE: radon2config <configDir> <dbConnectionString>\n");
      return -1;
    }


    char *dir = argv[1];
    char *connectionString = argv[2];

    char *configFile = getenv(SMARTMET_GRID_CONFIG_FILE);
    if (configFile == nullptr)
    {
      fprintf(stderr,"%s not defined!\n",SMARTMET_GRID_CONFIG_FILE);
      return -1;
    }

    Identification::gridDef.init(configFile);

    PGconn *conn = PQconnectdb(connectionString);
    if (PQstatus(conn) != CONNECTION_OK)
      error(PQerrorMessage(conn));

    create_fmi_parameters(conn,dir);
    create_fmi_parameterId_grib1(conn,dir);
    create_fmi_parameterId_grib2(conn,dir);
    create_fmi_parameterId_newbase(conn,dir);
    create_fmi_levels(conn,dir);
    create_fmi_levelId_grib1(conn,dir);
    create_fmi_levelId_grib2(conn,dir);
    create_fmi_geometries(conn,dir);
    create_fmi_producerId_grib(conn,dir);

    PQfinish(conn);

    return 0;
  }
  catch (SmartMet::Spine::Exception& e)
  {
    SmartMet::Spine::Exception exception(BCP,"Service call failed!",nullptr);
    exception.printError();
    return -7;
  }
}

