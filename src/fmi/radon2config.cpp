#include <macgyver/Exception.h>
#include "grid-files/common/ShowFunction.h"
#include "grid-files/common/GeneralFunctions.h"
#include "grid-files/common/ShowFunction.h"
#include "grid-files/identification/GridDef.h"

#include <libpq-fe.h>
#include <stdlib.h>
#include <string.h>

#define FUNCTION_TRACE FUNCTION_TRACE_OFF


using namespace SmartMet;




void error(char *mess)
{
  fprintf(stderr, "### %s\n", mess);
  exit(1);
}




void create_fmi_geometries(PGconn *conn,const char *dir)
{
  FUNCTION_TRACE
  try
  {
    char filename[300];
    sprintf(filename,"%s/fmi_geometries.csv",dir);

    FILE *file = fopen(filename,"we");
    if (file == nullptr)
    {
      Fmi::Exception exception(BCP,"Cannot create the file!");
      exception.addParameter("Filename",filename);
      throw exception;
    }

    fprintf(file,"# This file is automatically generated by the 'radon2config' program. It is used for mapping FMI geometries\n");
    fprintf(file,"# (defined in the Radon database) into the geometries defined in GRIB and NetCDF files.\n");
    fprintf(file,"#\n");
    fprintf(file,"# Do not edit this file, because all changes will be overridden.\n");
    fprintf(file,"#\n");


    fprintf(file,"\n# LATLON : projection,id,name,ni,nj,first_lon,first_lat,di,dj,scanning_mode,earthSemiMajor,earthSemiMinor,description\n");

    char sql[3000];
    char *p = sql;

    p += sprintf(p,"SELECT\n");
    p += sprintf(p,"  geometry_id,\n");
    p += sprintf(p,"  geometry_name,\n");
    p += sprintf(p,"  ni,\n");
    p += sprintf(p,"  nj,\n");
    p += sprintf(p,"  first_lon,\n");
    p += sprintf(p,"  first_lat,\n");
    p += sprintf(p,"  di,\n");
    p += sprintf(p,"  dj,\n");
    p += sprintf(p,"  scanning_mode,\n");
    p += sprintf(p,"  earth_semi_major,\n");
    p += sprintf(p,"  earth_semi_minor,\n");
    p += sprintf(p,"  description\n");
    p += sprintf(p,"FROM\n");
    p += sprintf(p,"  geom_latitude_longitude_v\n");
    p += sprintf(p,"ORDER BY\n");
    p += sprintf(p,"  geometry_id;\n");

    PGresult *res = PQexec(conn,sql);
    if (PQresultStatus(res) != PGRES_TUPLES_OK)
      error(PQresultErrorMessage(res));

    int fieldCount = PQnfields(res);
    int rowCount = PQntuples(res);

    for (int i = 0; i < rowCount; i++)
    {
      fprintf(file,"%d;%s;%s;%d;%d;%.6f;%.6f;%.6f;%.6f;%s;%.6f;%.6f;%s;\n",
        T::GridProjectionValue::LatLon,
        PQgetvalue(res,i,0),
        PQgetvalue(res,i,1),
        atoi(PQgetvalue(res,i,2)),
        atoi(PQgetvalue(res,i,3)),
        getLongitude(atof(PQgetvalue(res,i,4))),
        atof(PQgetvalue(res,i,5)),
        fabs(atof(PQgetvalue(res,i,6))),
        fabs(atof(PQgetvalue(res,i,7))),
        PQgetvalue(res,i,8),
        fabs(atof(PQgetvalue(res,i,9))),
        fabs(atof(PQgetvalue(res,i,10))),
        PQgetvalue(res,i,11));
    }

    PQclear(res);


    fprintf(file,"\n# ROTATED LATLON : projection,id,name,ni,nj,first_lon,first_lat,di,dj,scanning_mode,south_pole_lon,south_pole_lat,angle,earthSemiMajor,earthSemiMinor,description\n");

    p = sql;

    p += sprintf(p,"SELECT\n");
    p += sprintf(p,"  geometry_id,\n");
    p += sprintf(p,"  geometry_name,\n");
    p += sprintf(p,"  ni,\n");
    p += sprintf(p,"  nj,\n");
    p += sprintf(p,"  first_lon,\n");
    p += sprintf(p,"  first_lat,\n");
    p += sprintf(p,"  di,\n");
    p += sprintf(p,"  dj,\n");
    p += sprintf(p,"  scanning_mode,\n");
    p += sprintf(p,"  south_pole_lon,\n");
    p += sprintf(p,"  south_pole_lat,\n");
    p += sprintf(p,"  0,\n");                  // Angle of rotation
    p += sprintf(p,"  earth_semi_major,\n");
    p += sprintf(p,"  earth_semi_minor,\n");
    p += sprintf(p,"  description\n");
    p += sprintf(p,"FROM\n");
    p += sprintf(p,"  geom_rotated_latitude_longitude_v\n");
    p += sprintf(p,"ORDER BY\n");
    p += sprintf(p,"  geometry_id;\n");


    res = PQexec(conn,sql);
    if (PQresultStatus(res) != PGRES_TUPLES_OK)
      error(PQresultErrorMessage(res));

    fieldCount = PQnfields(res);
    rowCount = PQntuples(res);

    for (int i = 0; i < rowCount; i++)
    {
      fprintf(file,"%d;%s;%s;%d;%d;%.6f;%.6f;%.6f;%.6f;%s;%.6f;%.6f;%.6f;%.6f;%.6f;%s;\n",
        T::GridProjectionValue::RotatedLatLon,
        PQgetvalue(res,i,0),
        PQgetvalue(res,i,1),
        atoi(PQgetvalue(res,i,2)),
        atoi(PQgetvalue(res,i,3)),
        getLongitude(atof(PQgetvalue(res,i,4))),
        atof(PQgetvalue(res,i,5)),
        fabs(atof(PQgetvalue(res,i,6))),
        fabs(atof(PQgetvalue(res,i,7))),
        PQgetvalue(res,i,8),
        atof(PQgetvalue(res,i,9)),
        atof(PQgetvalue(res,i,10)),
        atof(PQgetvalue(res,i,11)),
        atof(PQgetvalue(res,i,12)),
        atof(PQgetvalue(res,i,13)),
        PQgetvalue(res,i,14));
    }

    PQclear(res);


    fprintf(file,"\n# LAMBERT CONFORMAL : projection,id,name,ni,nj,first_lon,first_lat,di,dj,scanning_mode,orientation,latin1,latin2,south_pole_lon,south_pole_lat,LaD,earthSemiMajor,earthSemiMinor,description\n");

    p = sql;

    p += sprintf(p,"SELECT\n");
    p += sprintf(p,"  geometry_id,\n");
    p += sprintf(p,"  geometry_name,\n");
    p += sprintf(p,"  ni,\n");
    p += sprintf(p,"  nj,\n");
    p += sprintf(p,"  first_lon,\n");
    p += sprintf(p,"  first_lat,\n");
    p += sprintf(p,"  di,\n");
    p += sprintf(p,"  dj,\n");
    p += sprintf(p,"  scanning_mode,\n");
    p += sprintf(p,"  orientation,\n");
    p += sprintf(p,"  latin1,\n");
    p += sprintf(p,"  latin2,\n");
    p += sprintf(p,"  south_pole_lon,\n");
    p += sprintf(p,"  south_pole_lat,\n");
    p += sprintf(p,"  latin1,\n");                  // LaD
    p += sprintf(p,"  earth_semi_major,\n");
    p += sprintf(p,"  earth_semi_minor,\n");
    p += sprintf(p,"  description\n");
    p += sprintf(p,"FROM\n");
    p += sprintf(p,"  geom_lambert_conformal_v\n");
    p += sprintf(p,"ORDER BY\n");
    p += sprintf(p,"  geometry_id;\n");


    res = PQexec(conn,sql);
    if (PQresultStatus(res) != PGRES_TUPLES_OK)
      error(PQresultErrorMessage(res));

    fieldCount = PQnfields(res);
    rowCount = PQntuples(res);

    for (int i = 0; i < rowCount; i++)
    {
      fprintf(file,"%d;%s;%s;%d;%d;%.6f;%.6f;%.6f;%.6f;%s;%.6f;%.6f;%.6f;%.6f;%.6f;%.6f;%.6f;%.6f;%s;\n",
        T::GridProjectionValue::LambertConformal,
        PQgetvalue(res,i,0),
        PQgetvalue(res,i,1),
        atoi(PQgetvalue(res,i,2)),
        atoi(PQgetvalue(res,i,3)),
        getLongitude(atof(PQgetvalue(res,i,4))),
        atof(PQgetvalue(res,i,5)),
        fabs(atof(PQgetvalue(res,i,6))),
        fabs(atof(PQgetvalue(res,i,7))),
        PQgetvalue(res,i,8),
        atof(PQgetvalue(res,i,9)),
        atof(PQgetvalue(res,i,10)),
        atof(PQgetvalue(res,i,11)),
        atof(PQgetvalue(res,i,12)),
        atof(PQgetvalue(res,i,13)),
        atof(PQgetvalue(res,i,14)),
        atof(PQgetvalue(res,i,15)),
        atof(PQgetvalue(res,i,16)),
        PQgetvalue(res,i,17));
    }

    PQclear(res);



    fprintf(file,"\n# LAMBERT EQUAL AREA : projection,id,name,ni,nj,first_lon,first_lat,di,dj,scanning_mode,orientation,latin,earthSemiMajor,earthSemiMinor,description\n");

    p = sql;

    p += sprintf(p,"SELECT\n");
    p += sprintf(p,"  geometry_id,\n");
    p += sprintf(p,"  geometry_name,\n");
    p += sprintf(p,"  ni,\n");
    p += sprintf(p,"  nj,\n");
    p += sprintf(p,"  first_lon,\n");
    p += sprintf(p,"  first_lat,\n");
    p += sprintf(p,"  di,\n");
    p += sprintf(p,"  dj,\n");
    p += sprintf(p,"  scanning_mode,\n");
    p += sprintf(p,"  orientation,\n");
    p += sprintf(p,"  latin,\n");
    p += sprintf(p,"  earth_semi_major,\n");
    p += sprintf(p,"  earth_semi_minor,\n");
    p += sprintf(p,"  description\n");
    p += sprintf(p,"FROM\n");
    p += sprintf(p,"  geom_lambert_equal_area_v\n");
    p += sprintf(p,"ORDER BY\n");
    p += sprintf(p,"  geometry_id;\n");


    res = PQexec(conn,sql);
    if (PQresultStatus(res) != PGRES_TUPLES_OK)
      error(PQresultErrorMessage(res));

    fieldCount = PQnfields(res);
    rowCount = PQntuples(res);

    for (int i = 0; i < rowCount; i++)
    {
      fprintf(file,"%d;%s;%s;%d;%d;%.6f;%.6f;%.6f;%.6f;%s;%.6f;%.6f;%.6f;%.6f;%s;\n",
        T::GridProjectionValue::LambertAzimuthalEqualArea,
        PQgetvalue(res,i,0),
        PQgetvalue(res,i,1),
        atoi(PQgetvalue(res,i,2)),
        atoi(PQgetvalue(res,i,3)),
        getLongitude(atof(PQgetvalue(res,i,4))),
        atof(PQgetvalue(res,i,5)),
        fabs(atof(PQgetvalue(res,i,6))),
        fabs(atof(PQgetvalue(res,i,7))),
        PQgetvalue(res,i,8),
        atof(PQgetvalue(res,i,9)),
        atof(PQgetvalue(res,i,10)),
        atof(PQgetvalue(res,i,11)),
        atof(PQgetvalue(res,i,12)),
        PQgetvalue(res,i,13));
    }

    PQclear(res);


    fprintf(file,"\n# POLAR STEREOGRAPHIC : projection,id,name,ni,nj,first_lon,first_lat,di,dj,scanning_mode,orientation,laD,earthSemiMajor,earthSemiMinor,description\n");

    p = sql;

    p += sprintf(p,"SELECT\n");
    p += sprintf(p,"  geometry_id,\n");
    p += sprintf(p,"  geometry_name,\n");
    p += sprintf(p,"  ni,\n");
    p += sprintf(p,"  nj,\n");
    p += sprintf(p,"  first_lon,\n");
    p += sprintf(p,"  first_lat,\n");
    p += sprintf(p,"  di,\n");
    p += sprintf(p,"  dj,\n");
    p += sprintf(p,"  scanning_mode,\n");
    p += sprintf(p,"  orientation,\n");
    p += sprintf(p,"  60.0,\n");
    p += sprintf(p,"  earth_semi_major,\n");
    p += sprintf(p,"  earth_semi_minor,\n");
    p += sprintf(p,"  description\n");
    p += sprintf(p,"FROM\n");
    p += sprintf(p,"  geom_stereographic_v\n");
    p += sprintf(p,"ORDER BY\n");
    p += sprintf(p,"  geometry_id;\n");


    res = PQexec(conn,sql);
    if (PQresultStatus(res) != PGRES_TUPLES_OK)
      error(PQresultErrorMessage(res));

    fieldCount = PQnfields(res);
    rowCount = PQntuples(res);

    for (int i = 0; i < rowCount; i++)
    {
      fprintf(file,"%d;%s;%s;%d;%d;%.6f;%.6f;%.6f;%.6f;%s;%.6f;%.6f;%.6f;%.6f;%s;\n",
        T::GridProjectionValue::PolarStereographic,
        PQgetvalue(res,i,0),
        PQgetvalue(res,i,1),
        atoi(PQgetvalue(res,i,2)),
        atoi(PQgetvalue(res,i,3)),
        getLongitude(atof(PQgetvalue(res,i,4))),
        atof(PQgetvalue(res,i,5)),
        fabs(atof(PQgetvalue(res,i,6))),
        fabs(atof(PQgetvalue(res,i,7))),
        PQgetvalue(res,i,8),
        atof(PQgetvalue(res,i,9)),
        atof(PQgetvalue(res,i,10)),
        atof(PQgetvalue(res,i,11)),
        atof(PQgetvalue(res,i,12)),
        PQgetvalue(res,i,13));
    }

    PQclear(res);


    fprintf(file,"\n# TRANSVERSE MERCATOR : projection,id,name,ni,nj,first_lon,first_lat,di,dj,scanning_mode,orientation,latin,earthSemiMajor,earthSemiMinor,description\n");

    p = sql;

    p += sprintf(p,"SELECT\n");
    p += sprintf(p,"  geometry_id,\n");
    p += sprintf(p,"  geometry_name,\n");
    p += sprintf(p,"  ni,\n");
    p += sprintf(p,"  nj,\n");
    p += sprintf(p,"  first_lon,\n");
    p += sprintf(p,"  first_lat,\n");
    p += sprintf(p,"  di,\n");
    p += sprintf(p,"  dj,\n");
    p += sprintf(p,"  scanning_mode,\n");
    p += sprintf(p,"  orientation,\n");
    p += sprintf(p,"  latin,\n");
    p += sprintf(p,"  earth_semi_major,\n");
    p += sprintf(p,"  earth_semi_minor,\n");
    p += sprintf(p,"  description\n");
    p += sprintf(p,"FROM\n");
    p += sprintf(p,"  geom_transverse_mercator_v\n");
    p += sprintf(p,"ORDER BY\n");
    p += sprintf(p,"  geometry_id;\n");


    res = PQexec(conn,sql);
    if (PQresultStatus(res) != PGRES_TUPLES_OK)
      error(PQresultErrorMessage(res));

    fieldCount = PQnfields(res);
    rowCount = PQntuples(res);

    for (int i = 0; i < rowCount; i++)
    {
      fprintf(file,"%d;%s;%s;%d;%d;%.6f;%.6f;%.6f;%.6f;%s;%.6f;%.6f;%.6f;%.6f;%s;\n",
        T::GridProjectionValue::TransverseMercator,
        PQgetvalue(res,i,0),
        PQgetvalue(res,i,1),
        atoi(PQgetvalue(res,i,2)),
        atoi(PQgetvalue(res,i,3)),
        getLongitude(atof(PQgetvalue(res,i,4))),
        atof(PQgetvalue(res,i,5)),
        fabs(atof(PQgetvalue(res,i,6))),
        fabs(atof(PQgetvalue(res,i,7))),
        PQgetvalue(res,i,8),
        atof(PQgetvalue(res,i,9)),
        atof(PQgetvalue(res,i,10)),
        atof(PQgetvalue(res,i,11)),
        atof(PQgetvalue(res,i,12)),
        PQgetvalue(res,i,13));
    }

    PQclear(res);


    fprintf(file,"\n# GAUSSIAN : projection,id,name,nj,first_point.x,first_point.y,scanning_mode,n,point_along_parallels,description\n");

    p = sql;

    p += sprintf(p,"SELECT\n");
    p += sprintf(p,"  id,\n");
    p += sprintf(p,"  name,\n");
    p += sprintf(p,"  nj,\n");
    p += sprintf(p,"  ST_X(first_point),\n");
    p += sprintf(p,"  ST_Y(first_point),\n");
    p += sprintf(p,"  scanning_mode,\n");
    p += sprintf(p,"  n,\n");
    p += sprintf(p,"  points_along_parallels,\n");
    p += sprintf(p,"  description\n");
    p += sprintf(p,"FROM\n");
    p += sprintf(p,"  geom_reduced_gaussian\n");
    p += sprintf(p,"ORDER BY\n");
    p += sprintf(p,"  id;\n");


    res = PQexec(conn,sql);
    if (PQresultStatus(res) != PGRES_TUPLES_OK)
      error(PQresultErrorMessage(res));

    fieldCount = PQnfields(res);
    rowCount = PQntuples(res);

    for (int i = 0; i < rowCount; i++)
    {
      fprintf(file,"%d;%s;%s;%d;%.6f;%.6f;%s;%d;%d;%s;\n",
        T::GridProjectionValue::Gaussian,
        PQgetvalue(res,i,0),
        PQgetvalue(res,i,1),
        atoi(PQgetvalue(res,i,2)),
        atof(PQgetvalue(res,i,3)),
        atof(PQgetvalue(res,i,4)),
        PQgetvalue(res,i,5),
        atoi(PQgetvalue(res,i,6)),
        atoi(PQgetvalue(res,i,7)),
        PQgetvalue(res,i,8));

      for (int f=0; f< fieldCount; f++)
      {
        fprintf(file,"%s;",PQgetvalue(res,i,f));
      }
      fprintf(file,"\n");
    }

    PQclear(res);


    fclose(file);
  }
  catch (...)
  {
    throw Fmi::Exception(BCP, "Operation failed!", nullptr);
  }
}




void create_fmi_levelId_grib2(PGconn *conn,const char *dir)
{
  FUNCTION_TRACE
  try
  {
    char filename[300];
    sprintf(filename,"%s/fmi_levelId_grib2.csv",dir);

    FILE *file = fopen(filename,"we");
    if (file == nullptr)
    {
      Fmi::Exception exception(BCP,"Cannot create the file!");
      exception.addParameter("Filename",filename);
      throw exception;
    }

    fprintf(file,"#################################################################################\n");
    fprintf(file,"#\n");
    fprintf(file,"# This file defines FMI level identifiers for GRIB2 files. The main purpose\n");
    fprintf(file,"# of this file is to identify GRIB2 levels according to GRIB2 (header) fields so\n");
    fprintf(file,"# that we will get unique FMI level identifiers for them.\n");
    fprintf(file,"#\n");
    fprintf(file,"# Notice that this file contains default definitions that comes with \n");
    fprintf(file,"# the installation package. You should use another file for your own definitions\n");
    fprintf(file,"# (for example 'ext/fmi_levelId_grib2.csv'. Add the name of your file into the\n");
    fprintf(file,"# 'grid-files.conf' file so that the programs can find it.\n");
    fprintf(file,"#\n");
    fprintf(file,"# Fields:\n");
    fprintf(file,"#   1 FMI level id\n");
    fprintf(file,"#   2 Fields used for identification\n");
    fprintf(file,"#\n");
    fprintf(file,"#################################################################################\n");
    fprintf(file,"#\n");


    char sql[3000];
    char *p = sql;

    p += sprintf(p,"SELECT DISTINCT\n");
    p += sprintf(p,"  level_grib2.level_id,\n");
    p += sprintf(p,"  producer_grib.ident,\n");
    p += sprintf(p,"  producer_grib.centre,\n");
    p += sprintf(p,"  level_grib2.grib_level_id\n");
    p += sprintf(p,"FROM\n");
    p += sprintf(p,"  level_grib2 LEFT OUTER JOIN producer_grib ON (level_grib2.producer_id = producer_grib.producer_id)\n");
    p += sprintf(p,"ORDER BY\n");
    p += sprintf(p,"  level_grib2.level_id,producer_grib.centre,producer_grib.ident,level_grib2.grib_level_id;\n");


    int fmiLevelId = 0;
    int gribLevelId = 0;

    PGresult *res = PQexec(conn,sql);
    if (PQresultStatus(res) != PGRES_TUPLES_OK)
      error(PQresultErrorMessage(res));

    int rowCount = PQntuples(res);

    for (int i = 0; i < rowCount; i++)
    {
      int fid = atoi(PQgetvalue(res,i,0));
      int pid = atoi(PQgetvalue(res,i,1));
      int cid = atoi(PQgetvalue(res,i,2));
      int gid = atoi(PQgetvalue(res,i,3));
      if (fmiLevelId != fid)
      {
        gribLevelId = gid;
        fmiLevelId = fid;
        fprintf(file,"\n%d;typeOfFirstFixedSurface=%d;\n",fid,gid);
      }
      else
      {
        if (gid != gribLevelId)
        {
          fprintf(file,"%d;generatingProcessIdentifier=%d,centre=%d,typeOfFirstFixedSurface=%d;\n",fid,pid,cid,gid);
        }
      }
    }

    fclose(file);
    PQclear(res);
  }
  catch (...)
  {
    throw Fmi::Exception(BCP, "Operation failed!", nullptr);
  }
}





void create_fmi_levels(PGconn *conn,const char *dir)
{
  FUNCTION_TRACE
  try
  {
    char filename[300];
    sprintf(filename,"%s/fmi_levels.csv",dir);

    FILE *file = fopen(filename,"we");
    if (file == nullptr)
    {
      Fmi::Exception exception(BCP,"Cannot create the file!");
      exception.addParameter("Filename",filename);
      throw exception;
    }

    fprintf(file,"# This file is automatically generated by the 'radon2config' program.\n");
    fprintf(file,"#\n");
    fprintf(file,"# Do not edit this file, because all changes will be overridden.\n");
    fprintf(file,"#\n");
    fprintf(file,"# FIELDS:\n");
    fprintf(file,"# 1) FmiLevelId\n");
    fprintf(file,"# 2) FmiLevelName\n");
    fprintf(file,"# 3) FmiLevelRelationship\n");
    fprintf(file,"#      0 Undefined\n");
    fprintf(file,"#      1 Linear\n");
    fprintf(file,"#      2 Logarithmic\n");
    fprintf(file,"#      3 Number\n");
    fprintf(file,"# 4) Description\n");
    fprintf(file,"# 5) Units\n");
    fprintf(file,"#\n");


    char sql[3000];
    char *p = sql;

    p += sprintf(p,"SELECT \n");
    p += sprintf(p,"  level.id,\n");
    p += sprintf(p,"  level.name,\n");
    p += sprintf(p,"  level.description,\n");
    p += sprintf(p,"  param_unit.name\n");
    p += sprintf(p,"FROM\n");
    p += sprintf(p,"  level LEFT OUTER JOIN param_unit ON (level.unit_id = param_unit.id)\n");
    p += sprintf(p,"ORDER BY\n");
    p += sprintf(p,"  level.id;\n");


    PGresult *res = PQexec(conn,sql);
    if (PQresultStatus(res) != PGRES_TUPLES_OK)
      error(PQresultErrorMessage(res));

    //int fieldCount = PQnfields(res);
    int rowCount = PQntuples(res);

    for (int i = 0; i < rowCount; i++)
    {
      int id = atoi(PQgetvalue(res,i,0));
      std::string name = PQgetvalue(res,i,1);
      std::string descr = PQgetvalue(res,i,2);
      std::string units = PQgetvalue(res,i,3);

      int type = 1;     // Default => levels have linear relationship, interpolation possible

      switch (id)
      {
        case 2:         // Pressure => levels have logarithmic relationship, interpolation possilbe
          type = 2;
          units = "Pa";  // We convert hehtopascals to pascals when reading level values
          break;

        case 3:         // Hybrid => levels have no relationship, interpolation not possible
          type = 3;
          break;
      }

      fprintf(file,"%d;%s;%d;%s;%s\n",id,name.c_str(),type,descr.c_str(),units.c_str());
    }

    fclose(file);
    PQclear(res);
  }
  catch (...)
  {
    throw Fmi::Exception(BCP, "Operation failed!", nullptr);
  }
}





void create_fmi_levelId_grib1(PGconn *conn,const char *dir)
{
  FUNCTION_TRACE
  try
  {
    char filename[300];
    sprintf(filename,"%s/fmi_levelId_grib1.csv",dir);

    FILE *file = fopen(filename,"we");
    if (file == nullptr)
    {
      Fmi::Exception exception(BCP,"Cannot create the file!");
      exception.addParameter("Filename",filename);
      throw exception;
    }

    fprintf(file,"#################################################################################\n");
    fprintf(file,"#\n");
    fprintf(file,"# This file defines FMI level identifiers for GRIB1 files. The main purpose\n");
    fprintf(file,"# of this file is to identify GRIB1 levels according to GRIB1 (header) fields so\n");
    fprintf(file,"# that we will get unique FMI level identifiers for them.\n");
    fprintf(file,"#\n");
    fprintf(file,"# Notice that this file contains default definitions that comes with \n");
    fprintf(file,"# the installation package. You should use another file for your own definitions\n");
    fprintf(file,"# (for example 'ext/fmi_levelId_grib1.csv'. Add the name of your file into the\n");
    fprintf(file,"# 'grid-files.conf' file so that the programs can find it.\n");
    fprintf(file,"#\n");
    fprintf(file,"# Fields:\n");
    fprintf(file,"#   1 FMI level id\n");
    fprintf(file,"#   2 Fields used for identification\n");
    fprintf(file,"#\n");
    fprintf(file,"#################################################################################\n");
    fprintf(file,"#\n");

    char sql[3000];
    char *p = sql;

    p += sprintf(p,"SELECT DISTINCT\n");
    p += sprintf(p,"  level_grib1.level_id,\n");
    p += sprintf(p,"  producer_grib.ident,\n");
    p += sprintf(p,"  producer_grib.centre,\n");
    p += sprintf(p,"  level_grib1.grib_level_id\n");
    p += sprintf(p,"FROM\n");
    p += sprintf(p,"  level_grib1 LEFT OUTER JOIN producer_grib ON (level_grib1.producer_id = producer_grib.producer_id)\n");
    p += sprintf(p,"ORDER BY\n");
    p += sprintf(p,"  level_grib1.level_id,producer_grib.centre,producer_grib.ident,level_grib1.grib_level_id;\n");


    int fmiLevelId = 0;
    int gribLevelId = 0;

    PGresult *res = PQexec(conn,sql);
    if (PQresultStatus(res) != PGRES_TUPLES_OK)
      error(PQresultErrorMessage(res));

    int rowCount = PQntuples(res);

    for (int i = 0; i < rowCount; i++)
    {
      int fid = atoi(PQgetvalue(res,i,0));
      int pid = atoi(PQgetvalue(res,i,1));
      int cid = atoi(PQgetvalue(res,i,2));
      int gid = atoi(PQgetvalue(res,i,3));
      if (fmiLevelId != fid)
      {
        gribLevelId = gid;
        fmiLevelId = fid;
        fprintf(file,"\n%d;indicatorOfTypeOfLevel=%d;\n",fid,gid);
      }
      else
      {
        if (gid != gribLevelId)
        {
          fprintf(file,"%d;generatingProcessIdentifier=%d,centre=%d,indicatorOfTypeOfLevel=%d;\n",fid,pid,cid,gid);
        }
      }
    }

    fclose(file);
    PQclear(res);
  }
  catch (...)
  {
    throw Fmi::Exception(BCP, "Operation failed!", nullptr);
  }
}





void create_fmi_parameterId_grib2(PGconn *conn,const char *dir)
{
  FUNCTION_TRACE
  try
  {
    char filename[300];
    sprintf(filename,"%s/fmi_parameterId_grib2.csv",dir);

    FILE *file = fopen(filename,"we");
    if (file == nullptr)
    {
      Fmi::Exception exception(BCP,"Cannot create the file!");
      exception.addParameter("Filename",filename);
      throw exception;
    }

    fprintf(file,"# This file is automatically generated by the 'radon2config' program. It defines mappings between\n");
    fprintf(file,"# FMI identifiers (used in Radon database) and identifiers used in GRIB2 files.\n");
    fprintf(file,"#\n");
    fprintf(file,"# Do not edit this file, because all changes will be overridden.\n");
    fprintf(file,"# You can add your own mappings into the 'fmi_parameterId_grib2_ext.csv' file.\n");
    fprintf(file,"#\n");
    fprintf(file,"# FIELDS:\n");
    fprintf(file,"# 1) FmiParameterId\n");
    fprintf(file,"# 2) FmiProducerId\n");
    fprintf(file,"# 3) GeneratingProcessIdentifier\n");
    fprintf(file,"# 4) Centre\n");
    fprintf(file,"# 5) Discipline\n");
    fprintf(file,"# 6) ParameterCategory\n");
    fprintf(file,"# 7) ParameterNumber\n");
    fprintf(file,"# 8) FmiParameterLevelId\n");
    fprintf(file,"# 9) GribParameterLevelId\n");
    fprintf(file,"# 10) ParameterLevel\n");
    fprintf(file,"#\n");

    char sql[3000];
    char *p = sql;

    p += sprintf(p,"SELECT DISTINCT\n");
    p += sprintf(p,"  param_grib2.param_id,\n");
    p += sprintf(p,"  param_grib2.producer_id,\n");
    p += sprintf(p,"  producer_grib.ident,\n");
    p += sprintf(p,"  producer_grib.centre,\n");
    p += sprintf(p,"  param_grib2.discipline,\n");
    p += sprintf(p,"  param_grib2.category,\n");
    p += sprintf(p,"  param_grib2.number,\n");
    p += sprintf(p,"  param_grib2.level_id,\n");
    p += sprintf(p,"  level_grib2.grib_level_id,\n");
    p += sprintf(p,"  param_grib2.level_value\n");
    p += sprintf(p,"FROM\n");
    p += sprintf(p,"  param_grib2 LEFT OUTER JOIN producer_grib ON (param_grib2.producer_id=producer_grib.producer_id)\n");
    p += sprintf(p,"  LEFT OUTER JOIN level_grib2 ON (param_grib2.level_id=level_grib2.level_id)\n");
    p += sprintf(p,"ORDER BY\n");
    p += sprintf(p,"  param_grib2.param_id,param_grib2.producer_id,producer_grib.ident;\n");

    PGresult *res = PQexec(conn,sql);
    if (PQresultStatus(res) != PGRES_TUPLES_OK)
      error(PQresultErrorMessage(res));

    int fieldCount = PQnfields(res);
    int rowCount = PQntuples(res);

    for (int i = 0; i < rowCount; i++)
    {
      for (int f=0; f< fieldCount; f++)
      {
        fprintf(file,"%s;",PQgetvalue(res,i,f));
      }
      fprintf(file,"\n");
    }

    fclose(file);
    PQclear(res);
  }
  catch (...)
  {
    throw Fmi::Exception(BCP, "Operation failed!", nullptr);
  }
}




void create_fmi_parameterId_grib1(PGconn *conn,const char *dir)
{
  FUNCTION_TRACE
  try
  {
    char filename[300];
    sprintf(filename,"%s/fmi_parameterId_grib1.csv",dir);

    FILE *file = fopen(filename,"we");
    if (file == nullptr)
    {
      Fmi::Exception exception(BCP,"Cannot create the file!");
      exception.addParameter("Filename",filename);
      throw exception;
    }

    fprintf(file,"# This file is automatically generated by the 'radon2config' program. It defines mappings between\n");
    fprintf(file,"# FMI identifiers (used in Radon database) and identifiers used in GRIB1 files.\n");
    fprintf(file,"#\n");
    fprintf(file,"# Do not edit this file, because all changes will be overridden.\n");
    fprintf(file,"# You can add your own mappings into the 'fmi_parameterId_grib1_ext.csv' file.\n");
    fprintf(file,"#\n");
    fprintf(file,"# FIELDS:\n");
    fprintf(file,"# 1) FmiParameterId\n");
    fprintf(file,"# 2) FmiProducerId\n");
    fprintf(file,"# 3) GeneratingProcessIdentifier\n");
    fprintf(file,"# 4) Centre\n");
    fprintf(file,"# 5) mGribTableVersion\n");
    fprintf(file,"# 6) mGribParameterNumber\n");
    fprintf(file,"# 7) mGribTimerangeIndicator\n");
    fprintf(file,"# 8) FmiParameterLevelId\n");
    fprintf(file,"# 9) GribParameterLevelId\n");
    fprintf(file,"# 10) ParameterLevel\n");
    fprintf(file,"#\n");

    char sql[3000];
    char *p = sql;

    p += sprintf(p,"SELECT DISTINCT\n");
    p += sprintf(p,"  param_grib1.param_id,\n");
    p += sprintf(p,"  param_grib1.producer_id,\n");
    p += sprintf(p,"  producer_grib.ident,\n");
    p += sprintf(p,"  producer_grib.centre,\n");
    p += sprintf(p,"  param_grib1.table_version,\n");
    p += sprintf(p,"  param_grib1.number,\n");
    p += sprintf(p,"  param_grib1.timerange_indicator,\n");
    p += sprintf(p,"  param_grib1.level_id,\n");
    p += sprintf(p,"  level_grib1.grib_level_id,\n");
    p += sprintf(p,"  param_grib1.level_value\n");
    p += sprintf(p,"FROM\n");
    p += sprintf(p,"  param_grib1 LEFT OUTER JOIN producer_grib ON (param_grib1.producer_id=producer_grib.producer_id)\n");
    p += sprintf(p,"  LEFT OUTER JOIN level_grib1 ON (param_grib1.level_id=level_grib1.level_id)\n");
    p += sprintf(p,"ORDER BY\n");
    p += sprintf(p,"  param_grib1.param_id,param_grib1.producer_id,producer_grib.ident;\n");


    PGresult *res = PQexec(conn,sql);
    if (PQresultStatus(res) != PGRES_TUPLES_OK)
      error(PQresultErrorMessage(res));

    int fieldCount = PQnfields(res);
    int rowCount = PQntuples(res);

    for (int i = 0; i < rowCount; i++)
    {
      for (int f=0; f< fieldCount; f++)
      {
        fprintf(file,"%s;",PQgetvalue(res,i,f));
      }
      fprintf(file,"\n");
    }

    fclose(file);
    PQclear(res);
  }
  catch (...)
  {
    throw Fmi::Exception(BCP, "Operation failed!", nullptr);
  }
}




void create_fmi_parameterId_newbase(PGconn *conn,const char *dir)
{
  FUNCTION_TRACE
  try
  {
    char filename[300];
    sprintf(filename,"%s/fmi_parameterId_newbase.csv",dir);

    FILE *file = fopen(filename,"we");
    if (file == nullptr)
    {
      Fmi::Exception exception(BCP,"Cannot create the file!");
      exception.addParameter("Filename",filename);
      throw exception;
    }

    fprintf(file,"# This file is automatically generated by the 'radon2config' program. It defines FMI parameters used\n");
    fprintf(file,"# in the Radon database.\n");
    fprintf(file,"#\n");
    fprintf(file,"# Do not edit this file, because all changes will be overridden.\n");
    fprintf(file,"#\n");
    fprintf(file,"# FIELDS:\n");
    fprintf(file,"# 1) FmiParameterId/FmiParameterName\n");
    fprintf(file,"# 2) NewbaseParameterId/NewbaseParameterName\n");
    fprintf(file,"# 3) ConversionFunction\n");
    fprintf(file,"# 4) ReverseConversionFunction\n");
    fprintf(file,"#\n");

    char sql[3000];
    char *p = sql;

    p += sprintf(p,"SELECT DISTINCT\n");
    p += sprintf(p,"  param.name,\n");
    p += sprintf(p,"  param.description,\n");
    p += sprintf(p,"  param.id,\n");
    p += sprintf(p,"  coalesce(param_newbase.univ_id,0),\n");
    p += sprintf(p,"  param_newbase.base,\n");
    p += sprintf(p,"  param_newbase.scale,\n");
    p += sprintf(p,"  param_unit.name\n");
    p += sprintf(p,"FROM\n");
    p += sprintf(p,"  param LEFT OUTER JOIN param_newbase ON (param.id = param_newbase.param_id),param_unit\n");
    p += sprintf(p,"WHERE\n");
    p += sprintf(p,"  param.unit_id=param_unit.id\n");
    // p += sprintf(p,"  param.unit_id=param_unit.id AND param_newbase.base = 0 AND param_newbase.scale = 1\n");
    p += sprintf(p,"ORDER BY\n");
    p += sprintf(p,"  param.id;\n");


    PGresult *res = PQexec(conn,sql);
    if (PQresultStatus(res) != PGRES_TUPLES_OK)
      error(PQresultErrorMessage(res));

    //int fieldCount = PQnfields(res);
    int rowCount = PQntuples(res);

    for (int i = 0; i < rowCount; i++)
    {
      std::string newbaseId = PQgetvalue(res,i,3);
      double base = toDouble(PQgetvalue(res,i,4));
      double scale = toDouble(PQgetvalue(res,i,5));
      std::string unit = PQgetvalue(res,i,6);


      Identification::NewbaseParameterDef paramDef;
      fprintf(file,"\n# %s\n",PQgetvalue(res,i,1));
      if (newbaseId > "0")
      {
        if (Identification::gridDef.getNewbaseParameterDefById(toUInt32(newbaseId),paramDef))
        {
          fprintf(file,"# %s[%s] => %s[%s]\n",PQgetvalue(res,i,0),PQgetvalue(res,i,2),paramDef.mParameterName.c_str(),newbaseId.c_str());
          fprintf(file,"%s;%s;",PQgetvalue(res,i,0),paramDef.mParameterName.c_str());
        }
        else
        {
          fprintf(file,"# %s[%s] => NEWBASE-PARAMETER[%s]\n",PQgetvalue(res,i,0),PQgetvalue(res,i,2),newbaseId.c_str());
          fprintf(file,"%s;%s;",PQgetvalue(res,i,0),PQgetvalue(res,i,3));
        }
      }
      else
      {
        fprintf(file,"# %s => UNKNOWN\n",PQgetvalue(res,i,0));
        fprintf(file,"# %s;%s;",PQgetvalue(res,i,0),PQgetvalue(res,i,3));
      }

      // We have to do some assumption when we define conversion functions. That's because
      // there seems to be a lot of strange conversion mappings in the Radon database.

      if (newbaseId > "0")
      {
        if (unit == "K")
        {
          fprintf(file,"SUM{$,-273.15};SUM{$,273.15};\n"); // Converting all kelvin values to celcius (assuming that the newbase has no Kelvin parameters)
        }
        else
        if (unit == "C")
          fprintf(file,";;\n"); // Assuming that celcius parameters do not need any conversion)
        else
        if (base != 0  &&  scale == 1)
        {
          fprintf(file,"SUM{$,%f};SUM{$,%f};\n",base,-base);
        }
        else
        if (base == 0  &&  scale != 1  &&  scale != 0)
        {
          fprintf(file,"MUL{$,%f};DIV{$,%f};\n",scale,scale);
        }
        else
          fprintf(file,";;\n");
      }
      else
        fprintf(file,";;\n");
    }

    fclose(file);
    PQclear(res);
  }
  catch (...)
  {
    throw Fmi::Exception(BCP, "Operation failed!", nullptr);
  }
}




void create_fmi_parameters(PGconn *conn,const char *dir)
{
  FUNCTION_TRACE
  try
  {
    char filename[300];
    sprintf(filename,"%s/fmi_parameters.csv",dir);

    FILE *file = fopen(filename,"we");
    if (file == nullptr)
    {
      Fmi::Exception exception(BCP,"Cannot create the file!");
      exception.addParameter("Filename",filename);
      throw exception;
    }

    fprintf(file,"# This file is automatically generated by the 'radon2config' program. It defines FMI parameters used\n");
    fprintf(file,"# in the Radon database.\n");
    fprintf(file,"#\n");
    fprintf(file,"# Do not edit this file, because all changes will be overridden.\n");
    fprintf(file,"#\n");
    fprintf(file,"# FIELDS:\n");
    fprintf(file,"# 1) FmiParameterId\n");
    fprintf(file,"# 2) FmiParameterName\n");
    fprintf(file,"# 3) FmiParameterUnits\n");
    fprintf(file,"# 4) FmiParameterDescription\n");
    fprintf(file,"# 5) AreaInterpolationMethod\n");
    fprintf(file,"# 6) TimeInterpolationMethod\n");
    fprintf(file,"# 7) LevelInterpolationMethod\n");
    fprintf(file,"# 8) DefaultPrecision\n");
    fprintf(file,"#\n");

    char sql[3000];
    char *p = sql;

    p += sprintf(p,"SELECT DISTINCT\n");
    p += sprintf(p,"  param.id,\n");
    p += sprintf(p,"  param.name,\n");
    p += sprintf(p,"  param_unit.name,\n");
    p += sprintf(p,"  param.description,\n");
    p += sprintf(p,"  param.interpolation_id,\n");
    p += sprintf(p,"  param.interpolation_id,\n");
    p += sprintf(p,"  param.interpolation_id\n");
    p += sprintf(p,"FROM\n");
    p += sprintf(p,"  param,param_unit\n");
    p += sprintf(p,"WHERE\n");
    p += sprintf(p,"  param.unit_id=param_unit.id\n");
    p += sprintf(p,"ORDER BY\n");
    p += sprintf(p,"  param.id;\n");


    PGresult *res = PQexec(conn,sql);
    if (PQresultStatus(res) != PGRES_TUPLES_OK)
      error(PQresultErrorMessage(res));

    int fieldCount = PQnfields(res);
    int rowCount = PQntuples(res);

    for (int i = 0; i < rowCount; i++)
    {
      for (int f=0; f < fieldCount; f++)
      {
        fprintf(file,"%s;",PQgetvalue(res,i,f));
      }
      std::string unit = PQgetvalue(res,i,3);

      if (unit == "C" || unit == "K" || unit == "m s-1" || unit == "cm" || unit == "mm")
        fprintf(file,"1;\n");
      else
      if (unit == "m" || unit == "kg" || unit == "Deg")
        fprintf(file,"2;\n");
      else
        fprintf(file,";\n");
    }

    fclose(file);
    PQclear(res);
  }
  catch (...)
  {
    throw Fmi::Exception(BCP, "Operation failed!", nullptr);
  }
}




void create_fmi_producerId_grib(PGconn *conn,const char *dir)
{
  FUNCTION_TRACE
  try
  {
    char filename[300];
    sprintf(filename,"%s/fmi_producerId_grib.csv",dir);

    FILE *file = fopen(filename,"we");
    if (file == nullptr)
    {
      Fmi::Exception exception(BCP,"Cannot create the file!");
      exception.addParameter("Filename",filename);
      throw exception;
    }

    fprintf(file,"# This file is automatically generated by the 'radon2config' program. It defines FMI producers used\n");
    fprintf(file,"# in the Radon database and their mappings to GRIB producers.\n");
    fprintf(file,"#\n");
    fprintf(file,"# Do not edit this file, because all changes will be overridden.\n");
    fprintf(file,"#\n");
    fprintf(file,"# FIELDS:\n");
    fprintf(file,"# 1) FmiProducerId\n");
    fprintf(file,"# 2) Type\n");
    fprintf(file,"# 3) Centre\n");
    fprintf(file,"# 4) GeneratingProcessIdentifier\n");
    fprintf(file,"# 5) FmiProducerName\n");
    fprintf(file,"# 6) FmiProducerDescription\n");
    fprintf(file,"#\n");


    char sql[3000];
    char *p = sql;

    p += sprintf(p,"SELECT DISTINCT\n");
    p += sprintf(p,"  fmi_producer.id,\n");
    p += sprintf(p,"  fmi_producer.type_id,\n");
    p += sprintf(p,"  producer_grib.centre,\n");
    p += sprintf(p,"  producer_grib.ident,\n");
    p += sprintf(p,"  fmi_producer.name,\n");
    p += sprintf(p,"  fmi_producer.description\n");
    p += sprintf(p,"FROM\n");
    p += sprintf(p,"  fmi_producer LEFT OUTER JOIN producer_grib ON (fmi_producer.id = producer_grib.producer_id)\n");
    //p += sprintf(p,"  fmi_producer,producer_grib\n");
    //p += sprintf(p,"WHERE\n");
    //p += sprintf(p,"  fmi_producer.id=producer_grib.producer_id\n");
    p += sprintf(p,"ORDER BY\n");
    p += sprintf(p,"  fmi_producer.id,producer_grib.centre,producer_grib.ident;\n");

    PGresult *res = PQexec(conn,sql);
    if (PQresultStatus(res) != PGRES_TUPLES_OK)
      error(PQresultErrorMessage(res));

    int fieldCount = PQnfields(res);
    int rowCount = PQntuples(res);

    for (int i = 0; i < rowCount; i++)
    {
      for (int f=0; f< fieldCount; f++)
      {
        fprintf(file,"%s;",PQgetvalue(res,i,f));
      }
      fprintf(file,"\n");
    }

    fclose(file);
    PQclear(res);
  }
  catch (...)
  {
    throw Fmi::Exception(BCP, "Operation failed!", nullptr);
  }
}



void create_fmi_forecastTypes(PGconn *conn,const char *dir)
{
  FUNCTION_TRACE
  try
  {
    char filename[300];
    sprintf(filename,"%s/fmi_forecastTypes.csv",dir);

    FILE *file = fopen(filename,"we");
    if (file == nullptr)
    {
      Fmi::Exception exception(BCP,"Cannot create the file!");
      exception.addParameter("Filename",filename);
      throw exception;
    }

    fprintf(file,"# This file is automatically generated by the 'radon2config' program.\n");
    fprintf(file,"#\n");
    fprintf(file,"# Do not edit this file, because all changes will be overridden.\n");
    fprintf(file,"#\n");
    fprintf(file,"# FIELDS:\n");
    fprintf(file,"# 1) FmiForecastTypeId\n");
    fprintf(file,"# 2) FmiForcastTypeName\n");
    fprintf(file,"# 3) Description\n");
    fprintf(file,"#\n");


    char sql[3000];
    char *p = sql;

    p += sprintf(p,"SELECT \n");
    p += sprintf(p,"  id,\n");
    p += sprintf(p,"  name,\n");
    p += sprintf(p,"  description\n");
    p += sprintf(p,"FROM\n");
    p += sprintf(p,"  forecast_type\n");
    p += sprintf(p,"ORDER BY\n");
    p += sprintf(p,"  id;\n");


    PGresult *res = PQexec(conn,sql);
    if (PQresultStatus(res) != PGRES_TUPLES_OK)
      error(PQresultErrorMessage(res));

    //int fieldCount = PQnfields(res);
    int rowCount = PQntuples(res);

    for (int i = 0; i < rowCount; i++)
    {
      int id = atoi(PQgetvalue(res,i,0));
      std::string name = PQgetvalue(res,i,1);
      std::string descr = PQgetvalue(res,i,2);

      fprintf(file,"%d;%s;%s\n",id,name.c_str(),descr.c_str());
    }
    fclose(file);
    PQclear(res);
  }
  catch (...)
  {
    throw Fmi::Exception(BCP, "Operation failed!", nullptr);
  }
}



void create_fmi_aggregations(PGconn *conn,const char *dir)
{
  FUNCTION_TRACE
  try
  {
    char filename[300];
    sprintf(filename,"%s/fmi_aggregations.csv",dir);

    FILE *file = fopen(filename,"we");
    if (file == nullptr)
    {
      Fmi::Exception exception(BCP,"Cannot create the file!");
      exception.addParameter("Filename",filename);
      throw exception;
    }

    fprintf(file,"# This file is automatically generated by the 'radon2config' program.\n");
    fprintf(file,"#\n");
    fprintf(file,"# Do not edit this file, because all changes will be overridden.\n");
    fprintf(file,"#\n");
    fprintf(file,"# FIELDS:\n");
    fprintf(file,"# 1) FmiAggregationId\n");
    fprintf(file,"# 2) FmiAggregationName\n");
    fprintf(file,"# 3) Description\n");
    fprintf(file,"#\n");


    char sql[3000];
    char *p = sql;

    p += sprintf(p,"SELECT \n");
    p += sprintf(p,"  id,\n");
    p += sprintf(p,"  name,\n");
    p += sprintf(p,"  description\n");
    p += sprintf(p,"FROM\n");
    p += sprintf(p,"  aggregation\n");
    p += sprintf(p,"ORDER BY\n");
    p += sprintf(p,"  id;\n");


    PGresult *res = PQexec(conn,sql);
    if (PQresultStatus(res) != PGRES_TUPLES_OK)
      error(PQresultErrorMessage(res));

    //int fieldCount = PQnfields(res);
    int rowCount = PQntuples(res);

    for (int i = 0; i < rowCount; i++)
    {
      int id = atoi(PQgetvalue(res,i,0));
      std::string name = PQgetvalue(res,i,1);
      std::string descr = PQgetvalue(res,i,2);

      fprintf(file,"%d;%s;%s\n",id,name.c_str(),descr.c_str());
    }
    fclose(file);
    PQclear(res);
  }
  catch (...)
  {
    throw Fmi::Exception(BCP, "Operation failed!", nullptr);
  }
}



void create_fmi_processingTypes(PGconn *conn,const char *dir)
{
  FUNCTION_TRACE
  try
  {
    char filename[300];
    sprintf(filename,"%s/fmi_processingTypes.csv",dir);

    FILE *file = fopen(filename,"we");
    if (file == nullptr)
    {
      Fmi::Exception exception(BCP,"Cannot create the file!");
      exception.addParameter("Filename",filename);
      throw exception;
    }

    fprintf(file,"# This file is automatically generated by the 'radon2config' program.\n");
    fprintf(file,"#\n");
    fprintf(file,"# Do not edit this file, because all changes will be overridden.\n");
    fprintf(file,"#\n");
    fprintf(file,"# FIELDS:\n");
    fprintf(file,"# 1) FmiProcessingTypeId\n");
    fprintf(file,"# 2) FmiProrcessingTypeName\n");
    fprintf(file,"# 3) Description\n");
    fprintf(file,"#\n");


    char sql[3000];
    char *p = sql;

    p += sprintf(p,"SELECT \n");
    p += sprintf(p,"  id,\n");
    p += sprintf(p,"  name,\n");
    p += sprintf(p,"  description\n");
    p += sprintf(p,"FROM\n");
    p += sprintf(p,"  processing_type\n");
    p += sprintf(p,"ORDER BY\n");
    p += sprintf(p,"  id;\n");


    PGresult *res = PQexec(conn,sql);
    if (PQresultStatus(res) != PGRES_TUPLES_OK)
      error(PQresultErrorMessage(res));

    //int fieldCount = PQnfields(res);
    int rowCount = PQntuples(res);

    for (int i = 0; i < rowCount; i++)
    {
      int id = atoi(PQgetvalue(res,i,0));
      std::string name = PQgetvalue(res,i,1);
      std::string descr = PQgetvalue(res,i,2);

      fprintf(file,"%d;%s;%s\n",id,name.c_str(),descr.c_str());
    }
    fclose(file);
    PQclear(res);
  }
  catch (...)
  {
    throw Fmi::Exception(BCP, "Operation failed!", nullptr);
  }
}







int main(int argc, char *argv[])
{
  FUNCTION_TRACE
  try
  {
    if (argc != 3)
    {
      fprintf(stderr,"USAGE: radon2config <configDir> <dbConnectionString>\n");
      return -1;
    }


    char *dir = argv[1];
    char *connectionString = argv[2];

    char *configFile = getenv(SMARTMET_GRID_CONFIG_FILE);
    if (configFile == nullptr)
    {
      fprintf(stderr,"%s not defined!\n",SMARTMET_GRID_CONFIG_FILE);
      return -1;
    }

    Identification::gridDef.init(configFile);

    PGconn *conn = PQconnectdb(connectionString);
    if (PQstatus(conn) != CONNECTION_OK)
      error(PQerrorMessage(conn));

    create_fmi_parameters(conn,dir);
    //create_fmi_parameterId_grib1(conn,dir);
    //create_fmi_parameterId_grib2(conn,dir);
    create_fmi_parameterId_newbase(conn,dir);
    create_fmi_levels(conn,dir);
    create_fmi_levelId_grib1(conn,dir);
    create_fmi_levelId_grib2(conn,dir);
    create_fmi_geometries(conn,dir);
    create_fmi_producerId_grib(conn,dir);
    create_fmi_forecastTypes(conn,dir);
    create_fmi_aggregations(conn,dir);
    create_fmi_processingTypes(conn,dir);

    PQfinish(conn);

    return 0;
  }
  catch (Fmi::Exception& e)
  {
    Fmi::Exception exception(BCP,"Service call failed!",nullptr);
    exception.printError();
    return -7;
  }
}

